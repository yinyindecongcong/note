//ADT for basic binary tree
#include <iostream>
using namespace std;
template <class entry>
struct binary_node{
  //constructor
  binary_node():lchild(0), rchild(0){}
  binary_node(const entry & key):data(key), lchild(0), rchild(0){}
  
  //data members
  entry data;
  binary_node<entry> * lchild;
  binary_node<entry> * rchild;
};

template <class entry>
class binary_tree{
public:
  //constructor
  binary_tree():root(0){}
  binary_tree(const binary_tree<entry> & original){
  	num_node = original.num_node;
  	au_copy(root, original.root);
  }
  //orerator =
  binary_tree & operator = (const binary_tree<entry> & original){
  	clear();
  	num_node = original.num_node;
  	au_copy(root, original.root);
  	return *this;
  }
  //destructor
  ~binary_tree(){
  	clear();
  }
  
  //function
  int size()const{ return num_node; }
  bool empty()const{ return num_node == 0; }
  int height()const{ return au_height(root); }
  void insert(const entry& key){ num_node++; au_insert(root, key); }
  void clear(){	num_node = 0;	au_clear(root); }
  //traverse
  void preorder(void (*visit)(entry&)){
  	preorder_recursive(root, visit);
  }
  void inorder(void (*visit)(entry&)){
  	inorder_recursive(root, visit);
  }
  void postorder(void (*visit)(entry&)){
  	postorder_recursive(root, visit);
  }
private:
  //auxiliary function
  void au_copy(binary_node<entry> *& obj, const binary_node<entry> * ori){
  	if (!ori) return;
  	obj = new binary_node<entry>(ori->data);
  	au_copy(obj->lchild, ori->lchild);
  	au_copy(obj->rchild, ori->rchild);
  }
  int au_height(const binary_node<entry> * tree)const{
  	if (!tree) return 0;
  	return 1 + max(au_height(tree->lchild), au_height(tree->rchild));
  }
  void au_insert(binary_node<entry> *& root, const entry& key){
  	if (!root){root = new binary_node<entry>(key); return; }
	if (key == root->data) return;
  	if (key < root->data) au_insert(root->lchild, key);
  	else if (key > root->data) au_insert(root->rchild, key);
  }
  void au_clear(binary_node<entry> *& root){
  	if (!root) return;
  	au_clear(root->lchild);
  	au_clear(root->rchild);
  	delete root;
  }
  void preorder_recursive(binary_node<entry> *root, void (*visit)(entry&)){
  	if (!root) return;
  	visit(root->data);
  	preorder_recursive(root->lchild, visit);
  	preorder_recursive(root->rchild, visit);
  }
  void inorder_recursive(binary_node<entry> *root, void (*visit)(entry&)){
  	if (!root) return;
  	inorder_recursive(root->lchild, visit);
  	visit(root->data);
  	inorder_recursive(root->rchild, visit);
  }
  void postorder_recursive(binary_node<entry> *root, void (*visit)(entry&)){
  	if (!root) return;
  	postorder_recursive(root->lchild, visit);
  	postorder_recursive(root->rchild, visit);
  	visit(root->data);
  }	
private:
  binary_node<entry> * root;
  int num_node;
};
template <class entry>
void visit(entry& key){
  	cout << key << endl;
}
int main(){
	binary_tree<int> T1;
	binary_tree<int> T3;
	T1.insert(6);
	T1.insert(2);
	T1.insert(1);
	T1.insert(3);
	T1.insert(7);
	T1.insert(9);
	T1.insert(8);
	T1.insert(10);
	T1.inorder(visit);
	binary_tree<int> T2(T1);
	T1.clear();
	T2.inorder(visit);
	T3 = T2;
	T2.clear();
	T3.inorder(visit);
	cout << T3.size() << ' ' << T3.height() << endl;
}


//ADT for BST
//
template <class entry>
class Search_tree :public binary_tree<entry>{
public:
	bool insert(const entry& key){
		num_node++;
		return insert_bst(root, key);
	}
	bool search(entry& key){
		binary_node<entry> * found = search_bst(root, key);
		if (!found) return 0;
		key = found->data;
		return 1;
	}
	bool remove(const entry& key){
		if (remove_bst(root, key)) {
			num_node--;
			return 1;
		}
		return 0;
	}
private:
	bool insert_bst(binary_node<entry> *& root, const entry& key){
		if (!root){root = new binary_node<entry>(key); return 1; }
		if (key == root->data) return 0;
  		if (key < root->data) return insert_bst(root->lchild, key);
  		else if (key > root->data) return insert_bst(root->rchild, key);
	}
	binary_node<entry> * search_bst(binary_node<entry> * root, const entry& key){
		if (!root || root->data == key) return root;
		if (key < root->data) return search_bst(root->lchild, key);
		if (key > root->data) return search_bst(root->rchild, key);
	}
	bool remove_bst(binary_node<entry> *& root, const entry& key){
		if (!root || root->data == key) return au_remove_bst(root);
		if (key < root->data) return remove_bst(root->lchild, key);
		return remove_bst(root->rchild, key);
	}
	bool au_remove_bst(binary_node<entry> *& root){
		if (!root) return 0;
		binary_node<entry> * to_delete = root; 
		if (!root->lchild) root = root->rchild;
		else if (!root->rchild)	root = root->lchild;
		else{
			binary_node<entry> * s = root;
			to_delete = to_delete->lchild;
			while(to_delete->rchild){
				s = to_delete;
				to_delete = to_delete->rchild;
			}
			root->data = to_delete->data;
			if (s == root) s->lchild = to_delete->lchild;
			else s->rchild = to_delete->lchild;
		}
		delete to_delete;
		return 1;
	}
};
